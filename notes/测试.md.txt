# 一、解题思路

## 面试官想考察什么

表面上看，测试问题主要考察你能否想到周全完备的测试用例。这在某种程度上也是对的，求职者确实需要想出一系列合理的测试用例。

但除此之外，面试官还想考察以下几个方面：

**全局观**

你是否真的了解软件是怎么回事？你能否正确区分测试用例的优先顺序？比如说，假设你被问到该如何测试像亚马逊这样的电子商务系统。若能确保产品图片显示位置正确，当然也不错，但最重要的还是确保支付流程万无一失，货品能顺利地进入发货流程，并且顾客绝对不能被重复扣款。

**懂整合**

你是否了解软件的工作原理？该如何将它们整合成更大的软件生态系统？假设要测试谷歌电子表格（Spreadsheets），你自然会想到测试文档的打开、存储及编辑功能。但是，实际上，谷歌电子表格也是大型软件生态系统的重要组成部分之一。所以，你还需将它与 Gmail、各种插件和其他模块整合在一起进行测试。

**会组织**

你能否有条有理地处理问题？还是处理问题时毫无条理？被要求提出照相机的测试用例时，有些求职者只会一股脑儿倒出一些杂乱无章的想法。而优秀的求职者却能将测试功能分为几类，比如拍照、照片管理、设置，等等。在创建测试用例时，这种结构化处理方法还有助于你将工作做得更周全。

**可操作**

你制定的测试计划是否合理，行之有效？比如，如有用户报告，软件会在打开某张图片时崩溃，而你却只是要求他们重新安装软件，这显然太不实际了。你的测试计划必须切实可行，便于公司操作落实。

## 分类

测试问题一般分为以下四类：

- 测试现实生活中的事物（比如一支笔）
- 测试一套软件
- 编写代码测试一个函数
- 调试解决已知问题

## 测试现实生活中的事物

比如有这么一个问题：如何测试一枚回形针？

**步骤一：使用者是哪些人？做什么用？**

你需要跟面试官讨论一下，谁会使用这个产品，做什么用。回答可能出乎你的意料，比如，回答可能是“老师，把纸张夹在一起”或“艺术家，为了弯成动物的造型”。又或者，两者皆要考虑。这个问题的答案，将影响你怎么处理后续问题。

**步骤二：有哪些用例**

列出回形针的一系列用例，这对解决问题很有帮助。在这个例子中，用例可能是，将纸张固定在一起，且不得破坏纸张。

若是其他问题，可能会有多个用例。比如，某产品要能够发送和接收内容，或擦写和删除功能，等等。

**步骤三：有哪些使用限制**

使用限制可能是，回形针一次可以夹最多 30 张纸，且不会造成永久性损害（比如弯掉）。另外，可以夹 30 到 50 张纸时，只不过会发生轻微变形。

同时，使用限制也要考虑环境因素。比如，回形针可否在非常温暖的环境下（33～43 摄氏度）使用？在极寒环境下呢？

**步骤四：压力与失效情况下的状态如何**

没有产品是万无一失的，所以，在测试中，还必须分析失效情况。跟面试官探讨时，最好问一下在什么情况下产品失效是可接受的（甚至是必要的），以及什么样才算是失效。

举个例子，要你测试一台洗衣机，你可能会认为洗衣机至少要能洗 30 件 T 恤衫或裤子。一次放进 30 到 45 件衣服，可能会导致轻微失效，因为衣物洗得不够干净。若超过 45 件衣物，出现极端失效或许可以接受。不过，这里所谓的极端失效，应该是指洗衣机根本不该进水，绝对不应该让水溢出来或引发火灾。

**步骤五：如何执行测试**

有些情况下，讨论执行测试的细节可能很重要。比如，若要确保一把椅子能正常使用 5 年，你恐怕不会把它放在家里，等上 5 年再来看结果。相反，你需要定义何谓“正常”使用情况（每年会在椅子上坐多少次？扶手呢？）。然后，除了做一些手动测试，你可能还会想到找台机器，自动执行某些功能测试。

## 测试一套软件

测试软件与测试现实生活的事物非常相似。主要差异在于，软件测试往往更强调执行测试的细节。

软件测试主要有如下两个方面：

**手动测试与自动化测试**

理想情况下，我们当然希望能够自动化所有的测试工作，不过这不太现实。有些东西还是手动测试来的更好，因为某些功能对计算机而言过于定性，计算机很难有效地检查（比如，内容带有淫秽色情成分）。此外，计算机只能机械地识别明确告知过的情况，而人类就不一样了，通过观察可能发现有待验证的新问题。因此，在测试过程中，无论是人工还是计算机，两者都不可或缺。

**黑盒测试与白盒测试**

两者的区别反映了我们对软件内部机制的掌控程度。在黑盒测试中，我们只关心软件的表象，并且仅测试其功能。而在白盒测试中，我们会了解程序的内部机制，还可以分别对每一个函数单独进行测试。我们也可以自动执行部分黑盒测试，只不过难度要大得多。

具体的测试步骤如下：

**步骤 1：要做黑盒测试还是白盒测试？**

尽管通常我们会拖到测试后期才考虑这个问题，但我喜欢早点做出选择。不妨跟面试官确认一下，要做黑盒测试还是白盒测试，或是两者都要。

**步骤 2：使用者是哪些人？做什么用？**

一般来说，软件都会有一个或多个目标用户，设计各个功能时，就会考虑用户需求。比如，若要你测试一款家长用来监控网页浏览器的软件，那么，你的目标用户既包括家长（实施监控过滤哪些网站），又包括孩子（有些网站被过滤了）。用户也可能包括“访客”（也就是既不实施也不受监控的使用者）

**步骤 3：有哪些用例？**

在监控过滤软件中，家长的用例包括安装软件、更新过滤网站清单、移除过滤网站，以及供他们自己使用的不受限制的网络。对孩子而言，用例包括访问合法内容及“非法”内容。

切记，不可凭空想象来决定各种用例，应该与面试官交流讨论后确定。

**步骤 4：有哪些使用限制？**

大致定义好用例后，我们还需找出确切的意思。“网络被过滤屏蔽”具体指什么？只过滤屏蔽“非法”网页还是屏蔽整个网站？是否要求该软件具备“学习”能力，从而识别不良内容，抑或只是根据白名单或黑名单进行过滤？若要求具备学习能力并自动识别不良内容，允许多大的误报漏报率？

**步骤 5：压力条件和失效条件为何？**

软件的失效是不可避免的，那么，软件失效应该是什么样的？显然，就算软件失效了，也不能导致计算机宕机。在本例中，失效可能是软件未能屏蔽本该屏蔽的网站，或是屏蔽本来允许访问的网站。对于后一种情况，你或许应该与面试官讨论一下，是不是要让家长输入密码，允许访问该网站。

**步骤 6：有哪些测试用例？如何执行测试？**

这里才是手动测试和自动测试以及黑盒测试和白盒测试真正显示出差异的地方。

在步骤 3 和步骤 4 中，我们初步拟定了软件的用例，这里会进一步加以定义，并讨论该如何执行测试。具体需要测试哪些情况？其中哪些步骤可以自动化？哪些又需要人工介入？

请记住，在有些测试中，虽然自动化可以助你一臂之力，但它也有着重大缺陷。一般来说，在测试过程中，手动测试还是少不了的。

对着上面的清单一步步解决问题时，请不要想到什么就草率吐露。这会显得很没有条理，而且你肯定会遗漏重要环节。相反，你应该组织好自己的思路，先将测试工作分割为几个主要模块，然后逐一展开分析。 这样， 不仅可以给出一份更完整的测试用例清单，而且也显得你做事有层次、有条理。

## 测试一个函数

基本上，测试函数是测试中最简单的一种，与面试官的交流相对也会比较简短、清晰，因为，测试一个函数通常不外乎就是验证输入与输出。

话说回来，千万不要忽视与面试官交流的重要性。对于任意可能，特别是如何处理特定情况，你都应该深究到底。

假设要你编写代码测试对整数数组排序的函数 sort(int[] array)，可参考下面的解决步骤。

**步骤 1：定义测试用例**

一般来说，你应该考虑以下几种测试用例。

- 正常情况：输入正常数组时，该函数是否能生成正确的输出？务必记得考虑其中的潜在问题。比如，排序通常涉及某种分割处理，应该要合理的想一想，数组元素个数为奇数时，由于无法均分数组，算法可能无法处理。所以，测试用例必须涵盖元素个数为偶数与奇数的两种数组。

- 极端情况：传入空数组会出现什么问题？或传入一个很小的数组（只有一个元素）？此外，传入非常大数组又会如何呢？

- 空指针和“非法” 输入：值得花时间好好考虑一番，若函数接收到非法输入，该怎么处理。比如，你在测试生成第 n 项斐波那契数的函数，那么，在测试用例中，自然要考虑 n 为负数的情况。

- 奇怪的输入：第四种有可能出现的情况：奇怪的输入。传入一个有序数组会怎么样？或者，传入一个反向排序的数组呢？

只有充分了解函数功能，才能想到这些测试用例。如果你对各种限制条件不是很清楚，最好先向面试官问个清楚。

**步骤 2：定义预期结果**

通常，预期结果非常明显：正确的输出。然而，在某些情况下，你可能还需要验证其他情况。比如，如果 sort 函数返回的是一个已排序的新数组，那么，你可能还要验证一下原先的数组是否保持原样。

**步骤 3：编写测试代码**

有了测试用例，并定义好预期结果后，编写代码实现这些测试用例，也就水到渠成了。代码大致如下：

```java
void testAddThreeSorted() {
    MyList list = new MyList();
    list.addThreeSorted(3, 1, 2); // 按顺序添加 3 个元素
    assertEquals(list.getElement(0), 1);
    assertEquals(list.getElement(1), 2);
    assertEquals(list.getElement(2), 3)
}
```

## 调试与故障排除

测试问题的最后一种是，说明你会如何调试或排除已知故障。碰到这种问题，很多求职者都会支支吾吾，处理不当，给出诸如“重装软件”等不切实际的答案。其实，就像其他问题一样，还是有章可循的，也可以有条不紊地处理。

下面通过一个例子辅助说明，假设你是谷歌 Chrome 浏览器团队的一员，收到一份 bug 报告：Chrome 启动时会崩溃。你会怎么处理？

重新安装浏览器或许就能解决该用户的问题，但是，若其他用户碰到同样问题，怎么办？你的目标是搞清楚究竟出了什么问题，以便开发人员修复缺陷。

**步骤 1：理清状况**

首先，你应该多提问题，尽量了解当时的情况：

- 用户碰到这个问题有多久了？
- 该浏览器的版本号？在什么操作系统下运行？
- 该问题经常发生吗？或者，出问题的频率有多高？什么时候会发生？
- 有无提交错误报告？

**步骤 2：分解问题**

了解了问题发生时的具体状况，接下来，着手将问题分解为可测模块。在这个例子中，可以设想出以下操作步骤

- 转到 Windows 的“开始”菜单
- 点击 Chrome 图标
- 浏览器启动
- 浏览器载入参数设置
- 浏览器发送 HTTP 请求载入首页
- 浏览器收到 HTTP 回应
- 浏览器解析网页
- 浏览器显示网页内容

在上述过程中的某一点，有地方出错致使浏览器崩溃。优秀的测试人员会逐一排查每个步骤，诊断定位问题所在。

**步骤 3：创建特定的、可控的测试**

以上各个测试模块都应该有实际的指令动作——也就是你要求用户执行的、或是你自己可以做的操作步骤（从而在你自己的机器上予以重现）。在真实世界中，你面对的是一般客户，不可能给他们做不到或不愿做的操作指令。

# 二、面试考题

## 不借助任何测试工具对网页进行负载测试

负载测试（load test）不仅有助于定位 Web 应用性能的瓶颈，还能确定其最大连接数。同样地，它还能检查应用如何响应各种负载情况。

要进行负载测试，必须先确定对性能要求最高的场景，以及满足目标的性能衡量指标。一般来说，有待测量的对象包括：

- 响应时间
- 吞吐量
- 资源利用率
- 系统所能承受的最大负载

随后，我们设计各种测试模拟负载，细心测量上面的每一项。

若缺少正规的测试工具，我们可以自行打造。例如，可以创建成千上万的虚拟用户，模拟并发用户。我们会编写多线程的程序，新建成千上万个线程，每个线程扮演一个实际用户，载入待测页面。对于每个用户，可以利用程序来测量响应时间、数据 I/O（输入/输出），等等。

之后，还要分析测试期间收集的数据结果，并与可接受的值进行比较。

## 测试一支笔

这个问题很大程度上在于理解限制条件，并有条理、结构化地解决该问题。

为了理解有哪些限制条件，你应该抛出一系列疑问，针对某个问题了解“谁、什么、何地、何时、如何以及为什么”（只要与该问题相关，越多越好）。

为了说明上面这项技巧，我们来看看下面的模拟对话。

- 面试官：你会如何测试一支笔？
- 求职者：我想先了解一下这支笔。谁会使用这支笔？
- 面试官：可能是小孩。
- 求职者：嗯，有意思。他们会用这支笔做什么？写字、画画还是干别的？
- 面试官：画画。
- 求职者：好的，谢谢。画在哪里呢？纸张、布料还是墙壁上？
- 面试官：画在布料上。
- 求职者：那么，这支笔的笔头是什么样的？签字笔还是圆珠笔？要洗得掉的，还是洗不掉的？
- 面试官： 要求洗得掉。

在问了很多问题之后，你可以得出如下结论。

- 求职者：好的，综上，我理解如下：这支笔主要面向 5～10 岁的小孩，为签字笔头，有红、绿、蓝、黑四色，用来画画。画在布料上并且要求洗得掉。我的理解对吗？

此时，求职者面对的问题与乍看上去的问题差异很大，这种情况并不少见。实际上，许多面试官会故意给一个看似再清楚不过的问题（谁不知道笔是什么呢！），其实是在考查你，看你能否发现这个问题与最初理解的有很大差别。他们相信用户也会这么做，但用户多半是无意的。

至此，你已经知道自己要测试的是什么，接下来该提出测试计划了。这里的关键是结构。

想想测试对象或问题会涉及哪些方面，并以此为基础展开测试。这个问题涉及以下几个方面。

- 事实核查：核实这是一支签字笔，墨水颜色为要求的四种颜色之一。
- 预期用途：绘制，这支笔在布料上画得出来吗？
- 预期用途：水洗，画在布料上的墨迹洗得掉吗（哪怕已经过了一段时间）？是用热水、温水还是冷水才能洗掉？
- 安全性：这支笔对小孩是否安全（无毒）？
- 非预期用途：小孩还会怎么使用这支笔？他们可能在其他物体表面上涂鸦，因此还需检查他们的行为是否正确。他们还可能踩踏、乱扔这支笔，等等。你需要确认这支笔是否经受得住这些使用条件。

记住，对于任何测试问题，你都必须测试预期和非预期的场景。人们并不一定按照你预想的方式使用产品。

## 找出程序错误

```c++
unsigned int i;
for (i = 100; i >= 0; --i)
    printf(“%d\n”, i);
```

首先，根据定义，unsigned int 类型的变量一定会大于或等于零。因此，for 循环的测试条件一直为真，将陷入无限循环。

要打印 100 到 1 之间的所有整数，正确的做法是测试 i > 0。

另一个需要修正的地方是用 %u 代替 %d，因为这里打印的是 unsigned int 型变量。

```c++
unsigned int i;
for (i = 100; i > 0; --i)
    printf(“%u\n”, i);
```

## 找出程序崩溃的原因

有个应用程序一运行就崩溃，现在你拿到了源码。在调试器中运行 10 次之后，你发现该应用每次崩溃的位置都不一样。这个应用只有一个线程，并且只调用 C 标准库函数。究竟是什么样的编程错误导致程序崩溃？该如何逐一测试每种错误？

具体如何处理这个问题要视待诊断应用程序的类型而定。不过，我们还是可以给出一些随机崩溃的常见原因。

**随机变量**

该应用程序可能用到某个随机变量或可变分量，程序每次执行时取值不定。具体的例子包括用户输入、程序生成的随机数，或当前时间等。

**未初始化变量**

该应用程序可能包含一个未初始化变量，在某些语言中，该变量可能含有任意值。这个变量取不同值可能导致代码每次执行路径有所不同。

**内存泄漏**

该程序可能存在内存溢出。每次运行时引发问题的可疑进程随机不定，这与当时运行的进程数量有关。另外还包括堆溢出或栈内数据被破坏。

**外部依赖**

该程序可能依赖别的应用程序、机器或资源。要是存在多处依赖，程序就有可能在任意位置崩溃。

为了找出问题的原因，我们首先应该尽可能地了解这个应用程序。谁在运行这个程序？他们用它做什么？这个程序属于哪种应用？

此外，尽管应用程序每次崩溃的位置不尽相同，但还是有办法确定它可能与特定组件或场景有关。例如，有可能只是启动该应用程序而不进行其他操作时，这个程序从不崩溃。它只有在载入文件之后的某个时间点才会崩溃。或者，有可能每次崩溃都出现在底层组件如文件 I/O 上。

要解决这个问题，消除法也许值得一试。首先，关闭系统中其他所有应用，仔细追踪资源使用。如果该程序有些部分可以关掉，那就设法关掉。在另一台机器上运行该程序，看看能否重现同一问题。我们可以消除（或修改）的越多，就越容易定位原因。

此外，我们还可以借助工具检查特定情况。例如，要排查前面第二个原因，我们可以利用运行时工具来检查未初始化变量。

这些问题不仅考查你解决问题的方式，还考查你头脑风暴的能力。你是否会像热锅上的蚂蚁，胡乱给出一些建议？抑或以合乎逻辑的、有条理的方式处理问题？希望是后者。

## 在一个分布式银行系统中测试一台 ATM 机

对于这个问题，第一要务是厘清若干假设条件，请提出以下问题：

- 谁会使用 ATM 机？答案可能是“任何人”，或是“盲人”，或任意其他可能的答案。
- 他们会用 ATM 机来做什么？答案可能是“取款”、“转账”、“查询余额”，等等。
- 我们有什么工具来测试呢？我们可以查看代码吗？还是只能访问 ATM 机？

一旦了解系统是什么样的，我们就会想着将问题分解成可测试的子部分，包括：

- 登录
- 取款
- 存款
- 查询余额
- 转账

我们可能要搭配使用手动和自动测试。

- 手动测试会检查上述步骤的每一个环节，确保涵盖所有错误情况（余额不足、新开账户、不存在的账户，等等）。
- 自动测试稍微复杂一点。我们会希望自动处理上述所有标准流程，还要找一些非常具体的问题，比如竞争条件。理想情况下，我们会设法建立一套有假帐户的封闭系统，以确保即使有人从不同地点快速取款和存款，他也不会多得不应得的钱，或者损失应得的钱。

最重要的是，我们必须优先考虑安全性和可靠性。客户的帐户无时无刻都要处于被保护的状态，我们必须确保账目得到正确处理。没有人希望自己的钱不翼而飞。优秀的测试人员深谙整个系统里哪些事项是最重要的。
