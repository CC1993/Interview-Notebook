# 资料

- [StackOverflow](https://stackoverflow.com/questions/tagged/c%2b%2b)
- [涵盖 20 多所互联网公司的校招 C++ 面经](https://www.nowcoder.com/discuss/55353)
- [interview](https://github.com/huihut/interview)

# int 与 string 转换

```c++
string s = "123";
int x = atoi(s.c_str());
cout << x << endl;
```

```c++
int x = 123;
string s = to_string(x);
cout << s << endl;
```

[Easiest way to convert int to string in C++](https://stackoverflow.com/questions/5590381/easiest-way-to-convert-int-to-string-in-c)

# 实现接口

- 将析构函数定义为虚函数
- 将所有方法定义为纯虚函数

```c++
class IDemo {
public:
    virtual ~IDemo() {}

    virtual void OverrideMe() = 0;
};

class Child : public IDemo {
public:
    virtual void OverrideMe() {
        //do stuff
    }
};
```

# new 与 delete

# C 与 C++

# C++ 与 Java

# C++ 11

# const

# static

# struct 与 class

# define 与 const

# 方法的重载与重写

[Override and overload in C++](https://stackoverflow.com/questions/429125/override-and-overload-in-c)


# 类大小计算

```c++
class A {
};

class B {
    virtual Fun() {}
};

class C {
    static int a;
};

class D {
    int a;
};

class E {
    static int a;
    int b;
};

int main() {
    cout << sizeof(A) << endl; // 1
    cout << sizeof(B) << endl; // 4(32 位机器) 8(64 位机器)
    cout << sizeof(C) << endl; // 1
    cout << sizeof(D) << endl; // 4
    cout << sizeof(E) << endl; // 4
}
```

# 字符串切割

```c++
string s = "Somewhere down the road";
istringstream iss(s);
vector<string> tokens;
string tmp;
while(iss >> tmp) {
    tokens.push_back(tmp);
    cout << tmp << endl;
}
```

[The most elegant way to iterate the words of a string [closed]](https://stackoverflow.com/questions/236129/the-most-elegant-way-to-iterate-the-words-of-a-string)

# 指针与引用

- 每个指针都有地址，而引用共享被引用变量的地址。引用也是一个变量，虽然它也有一个地址，但是编译器不会把这个地址显示出来，详情请见：[What and where are the stack and heap?](https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap#79936)

```c++
int x = 0;
int &r = x;
cout << &x << endl; // 0xffffcbe4
cout << &r << endl; // 0xffffcbe4
int *p1 = &x;
int *p2 = &x;
cout << &p1 << endl; // 0xffffcbe8
cout << &p2 << endl; // 0xffffcbe0
```

- 指针可以被重新赋值，但是引用不能，而且引用在初始化的时候就需要进行赋值。也可以理解为引用是常量。

```c++
int x = 5;
int y = 6;
int *p;
p = &x;
p = &y;
*p = 10;
cout << x << endl; // 5
cout << y << endl; // 10
```

```c++
int x = 5;
int y = 6;
// int &r; // Declaration of reference variable requires an initializer
int &r = x;
// &r = y;
```

- 可以有多级指针，但是不能有多级引用。

```c++
int x = 0;
int *p = &x;
int **pp = &p;
**pp = 4;
cout << x << endl; // 4
int &r = x;
// int &&rr = r;
```

- 指针的值要用 * 运算符取出，而引用的值可以直接使用。

```c++
int x = 1;
int *p = &x;
int &r = x;
cout << *p << endl;
cout << r << endl;
```

- 使用指针取出类或者结构体成员使用 -> 运算符，而引用直接使用 . 运算符。

```
Person a;
Person *ap = &a;
a.fun();
ap->fun();
```

- const 引用可以指向

```c++
const int &x = int(12);
//  int *y = &int(12);  // Address expression must be lvalue
```

[What are the differences between a pointer variable and a reference variable in C++?](https://stackoverflow.com/questions/57483/what-are-the-differences-between-a-pointer-variable-and-a-reference-variable-in)

# 栈与堆

[What and where are the stack and heap?](https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap)

# explicit 关键字

用来修饰构造函数，指示在使用这个构造函数创建对象的时候需要用明确指定参数的方式，而不能用赋值的方式进行隐式调用。这是为了安全性和可读性考虑，因为用隐式调用创建的方式有时候调用的构造函数和预先假设的不一样。

所谓的隐式调用，是指将赋值表达式的右值作为构造函数的第一个参数。

```c++
class Foo {
public:
    Foo(int x);
};

int main() {
    Foo foo = 1;
    return 0;
}
```

```c++
class Foo {
public:
    explicit Foo(int x);
};

int main() {
    // Foo foo = 1; // Types 'Foo' and 'int' are not compatible
    return 0;
}
```

# 强制类型转换

## C-Like

```c++
double x = 1.0;
int y = (int) x;
```

这种简单的转换在大多数情况下都有效，但是如果在不能进行转换的情况下也用这种方式进行强制类型转换，编译会通过但是运行会产生不可预期的错误。正是因为它不能在编译时进行类型检查，因此最好不要使用它。

```c++
class Dummy {
    double i, j;
};

class Addition {
    int x, y;
public:
    Addition(int a, int b) {
        x = a;
        y = b;
    }

    int result() { return x + y; }
};

int main() {
    Dummy d;
    Addition *pa = (Addition *) &d;
    cout << pa->result(); // -13136
    return 0;
}
```

## static_cast

static_cast is the first cast you should attempt to use. It does things like implicit conversions between types (such as int to float, or pointer to void*), and it can also call explicit conversion functions (or implicit ones). In many cases, explicitly stating static_cast isn't necessary, but it's important to note that the T(something) syntax is equivalent to (T) something and should be avoided (more on that later). A T(something, something_else) is safe, however, and guaranteed to call the constructor.

static_cast can also cast through inheritance hierarchies. It is unnecessary when casting upwards (towards a base class), but when casting downwards it can be used as long as it doesn't cast through virtual inheritance. It does not do checking, however, and it is undefined behavior to static_cast down a hierarchy to a type that isn't actually the type of the object.

```c++
class Base {
};

class Derived : public Base {
};

int main() {
    Base *a = new Base;
    Derived *b = static_cast<Derived *>(a);
    return 0;
}
```

## const_cast

const_cast can be used to remove or add const to a variable; no other C++ cast is capable of removing it (not even reinterpret_cast). It is important to note that modifying a formerly const value is only undefined if the original variable is const; if you use it to take the const off a reference to something that wasn't declared with const, it is safe. This can be useful when overloading member functions based on const, for instance. It can also be used to add const to an object, such as to call a member function overload.

const_cast also works similarly on volatile, though that's less common.

```c++
void print(char *str) {
    cout << str << '\n';
}

int main() {
    const char *c = "sample text";
    print(const_cast<char *> (c));
    return 0;
}
```

## dynamic_cast

dynamic_cast is almost exclusively used for handling polymorphism. You can cast a pointer or reference to any polymorphic type to any other class type (a polymorphic type has at least one virtual function, declared or inherited). You can use it for more than just casting downwards -- you can cast sideways or even up another chain. The dynamic_cast will seek out the desired object and return it if possible. If it can't, it will return nullptr in the case of a pointer, or throw std::bad_cast in the case of a reference.

dynamic_cast has some limitations, though. It doesn't work if there are multiple objects of the same type in the inheritance hierarchy (the so-called 'dreaded diamond') and you aren't using virtual inheritance. It also can only go through public inheritance - it will always fail to travel through protected or private inheritance. This is rarely an issue, however, as such forms of inheritance are rare.

```c++
class Base {
    virtual void dummy() {}
};

class Derived : public Base {
    int a;
};

int main() {
    try {
        Base *pba = new Derived;
        Base *pbb = new Base;
        Derived *pd = dynamic_cast<Derived *>(pba);
        if (pd == 0)
            cout << "Null pointer on first type-cast." << endl;
        pd = dynamic_cast<Derived *>(pbb);
        if (pd == 0)
            cout << "Null pointer on second type-cast." << endl;

    } catch (exception &e) {
        cout << "Exception: " << e.what();
    }
    return 0;
}
```

```
Null pointer on second type-cast.
```

## reinterpret_cast

reinterpret_cast is the most dangerous cast, and should be used very sparingly. It turns one type directly into another - such as casting the value from one pointer to another, or storing a pointer in an int, or all sorts of other nasty things. Largely, the only guarantee you get with reinterpret_cast is that normally if you cast the result back to the original type, you will get the exact same value (but not if the intermediate type is smaller than the original type). There are a number of conversions that reinterpret_cast cannot do, too. It's used primarily for particularly weird conversions and bit manipulations, like turning a raw data stream into actual data, or storing data in the low bits of an aligned pointer.

```c++
class A {
};

class B {
};

int main() {
    A *a = new A;
    B *b = reinterpret_cast<B *>(a);
}
```

- [When should static_cast, dynamic_cast, const_cast and reinterpret_cast be used?](https://stackoverflow.com/questions/332030/when-should-static-cast-dynamic-cast-const-cast-and-reinterpret-cast-be-used)
- [Type conversions](http://www.cplusplus.com/doc/tutorial/typecasting/)

# 位操作

```c++
bitset<5> x;
x[1] = 1;
x[2] = 0;
cout << x << endl; // 00010
```

```c++
struct bits {
    unsigned int a:1;
    unsigned int b:1;
    unsigned int c:1;
};

int main() {
    struct bits mybits;
    // 设置
    mybits.a = 1;
    // 清除
    mybits.b = 0;
    // 反转
    mybits.a = ~mybits.a;
}
```

[How do you set, clear, and toggle a single bit?](https://stackoverflow.com/questions/47981/how-do-you-set-clear-and-toggle-a-single-bit)

# using namespace 缺陷

如果两个命令空间都有相同的方法或者变量声明，那么使用 using namespace 来去除命名空间前缀就会出现运行时错误。

并且失去了命名空间前缀很难知道一个变量的具体用处，失去了可读性。

至于 std 命名空间，它有很多常见的标识符，这些表示符很有可能被其它命名空间使用。为了避免这种情况的发生，也最好不要去除 std 命名空间前缀。

```c++
namespace foo {
    int x;
    int y;
}

namespace bar {
    int x;
    int z;
}


using namespace foo;
using namespace bar;
using namespace std;

int main() {
    cout << x << endl;
    cout << y << endl;
    cout << z << endl;
}
```

```
error: reference to 'x' is ambiguous
```

[Why is “using namespace std” considered bad practice?](https://stackoverflow.com/questions/1452721/why-is-using-namespace-std-considered-bad-practice)

# include 使用

In practice, the difference is in the location where the preprocessor searches for the included file.

For `#include <filename>` the preprocessor searches in an implementation dependent manner, normally in search directories pre-designated by the compiler/IDE. This method is normally used to include standard library header files.

For `#include "filename"` the preprocessor searches first in the same directory as the file containing the directive, and then follows the search path used for the `#include <filename>` form. This method is normally used to include programmer-defined header files.

[What is the difference between #include <filename> and #include “filename”?](https://stackoverflow.com/questions/21593/what-is-the-difference-between-include-filename-and-include-filename)

# const 关键字

用于定义常量，一旦初始化之后就无法改变。

常量必须在定义的时候进行初始化，因此用 const 修饰成员变量，必须在构造函数列表中初始化。

const 修饰指针时，分为顶层 const 和底层 const。

顶层 const 表示指针本身是个常量。

```c++
int i = 0;
int* const p = &i;
```

底层 const 表示指针所指向的对象时一个常量。

```c++
const int i = 0;
const int* p = &i;
```

const 修饰成员函数，说明该函数不应该修改非静态成员，但是这并不是十分可靠的，指针所指的非成员对象值可能会被改变。

# static 关键字

[static 详解 ](http://blog.csdn.net/shanghairuoxiao/article/details/72904292)

# extern 关键字

[C/C++中 extern 关键字详解 ](http://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777431.html)

# volatile 关键字

关键字 volatile 的作用是指示编译器，即使代码不对变量做任何改动，该变量的值仍可能会被外界修改。操作系统、硬件或其他线程都有可能修改该变量。该变量的值有可能遭受意料之外的修改，因此，每一次使用时，编译器都会重新从内存中获取这个值，而不是从寄存器中获取。

volatile 变量不会被优化掉，这非常有用。设想有下面这个函数：

```c++
int opt = 1;
void Fn(void) {
    start:
        if (opt == 1) goto start;
        else break;
}
```

乍一看，上面的代码好像会进入无限循环，编译器可能会将这段代码优化成：
```c++
void Fn(void) {
    start:
        int opt = 1;
        if (true)
        goto start;
}
```

这样就变成了无限循环。然后，外部操作可能会将 0 写入变量 opt 的位置，从而终止循环。

为了防止编译器执行这类优化，我们需要设法通知编译器，系统其他部分可能会修改这个变量。具体做法就是使用 volatile 关键字，

# new 与 maclloc 区别

1. new 分配内存按照数据类型进行分配，malloc 分配内存按照大小分配；
2. new 不仅分配一段内存，而且会调用构造函数，但是 malloc 则不会。
3. new 返回的是指定对象的指针，而 malloc 返回的是 void\*，因此 malloc 的返回值一般都需要进行类型转化；
4. new 是一个操作符可以重载，malloc 是一个库函数；
5. new 分配的内存要用 delete 销毁，malloc 要用 free 来销毁；delete 销毁的时候会调用对象的析构函数，而 free 则不会；
6. malloc 分配的内存不够的时候，可以用 realloc 扩容。扩容的原理？new 没用这样操作；
7. new 如果分配失败了会抛出 bad_malloc 的异常，而 malloc 失败了会返回 NULL。因此对于 new，正确的姿势是采用 try...catch 语法，而 malloc 则应该判断指针的返回值。为了兼容很多 c 程序员的习惯，C++ 也可以采用 new nothrow 的方法禁止抛出异常而返回 NULL；
8. new 和 new[] 的区别，new[] 一次分配所有内存，多次调用构造函数，分别搭配使用 delete 和 delete[]，同理，delete[] 多次调用析构函数，销毁数组中的每个对象。而 malloc 则只能 sizeof(int) * n；
9. 如果不够可以继续谈 new 和 malloc 的实现，空闲链表，分配方法 ( 首次适配原则，最佳适配原则，最差适配原则，快速适配原则 )。delete 和 free 的实现原理，free 为什么直到销毁多大的空间？



# 指针和引用的区别

指针保存的是所指对象的地址，引用是所指对象的别名，指针需要通过解引用间接访问，而引用是直接访问；

指针可以改变地址，从而改变所指的对象，而引用必须从一而终；

引用在定义的时候必须初始化，而指针则不需要；

指针有指向常量的指针和指针常量，而引用没有常量引用；

指针更灵活，用的好威力无比，用的不好处处是坑，而引用用起来则安全多了，但是比较死板。

# 指针和数组的联系

一个一维 int 数组的数组名实际上是一个 int\* const 类型；
一个二维 int 数组的数组名实际上是一个 int (\*const p)[n];
数组名做参数会退化为指针

# 智能指针

构造函数中计数初始化为 1；
拷贝构造函数中计数值加 1；
赋值运算符中，左边的对象引用计数减一，右边的对象引用计数加一；
析构函数中引用计数减一；
在赋值运算符和析构函数中，如果减一后为 0，则调用 delete 释放对象。
share_prt 与 weak_ptr 的区别？

```c++
//share_ptr 可能出现循环引用，从而导致内存泄露
class A
{
public:
    share_ptr p;
};
class B
{
public:
    share_ptr p;
}
int main()
{
    while(true)
    {
        share_prt pa(new A()); //pa 的引用计数初始化为 1
        share_prt pb(new B()); //pb 的引用计数初始化为 1
        pa->p = pb; //pb 的引用计数变为 2
        pb->p = pa; //pa 的引用计数变为 2
    }
    //假设 pa 先离开，引用计数减一变为 1，不为 0 因此不会调用 class A 的析构函数，因此其成员 p 也不会被析构，pb 的引用计数仍然为 2；
    //同理 pb 离开的时候，引用计数也不能减到 0
    return 0;
}
/*
** weak_ptr 是一种弱引用指针，其存在不会影响引用计数，从而解决循环引用的问题
```




# 多态性

作者：oscarwin
链接：https://www.nowcoder.com/discuss/59394
来源：牛客网

C++多态性与虚函数表

C++多态的实现？
多态分为静态多态和动态多态。静态多态是通过重载和模板技术实现，在编译的时候确定。动态多态通过虚函数和继承关系来实现，执行动态绑定，在运行的时候确定。
动态多态实现有几个条件：
(1) 虚函数；
(2) 一个基类的指针或引用指向派生类的对象；
基类指针在调用成员函数 (虚函数) 时，就会去查找该对象的虚函数表。虚函数表的地址在每个对象的首地址。查找该虚函数表中该函数的指针进行调用。
每个对象中保存的只是一个虚函数表的指针，C++内部为每一个类维持一个虚函数表，该类的对象的都指向这同一个虚函数表。
虚函数表中为什么就能准确查找相应的函数指针呢？因为在类设计的时候，虚函数表直接从基类也继承过来，如果覆盖了其中的某个虚函数，那么虚函数表的指针就会被替换，因此可以根据指针准确找到该调用哪个函数。
虚函数的作用？

虚函数用于实现多态，这点大家都能答上来
但是虚函数在设计上还具有封装和抽象的作用。比如抽象工厂模式。
动态绑定是如何实现的？
第一个问题中基本回答了，主要都是结合虚函数表来答就行。

静态多态和动态多态。静态多态是指通过模板技术或者函数重载技术实现的多态，其在编译器确定行为。动态多态是指通过虚函数技术实现在运行期动态绑定的技术。

虚函数表

虚函数表是针对类的还是针对对象的？同一个类的两个对象的虚函数表是怎么维护的？

编译器为每一个类维护一个虚函数表，每个对象的首地址保存着该虚函数表的指针，同一个类的不同对象实际上指向同一张虚函数表。
纯虚函数如何定义，为什么对于存在虚函数的类中析构函数要定义成虚函数
为了实现多态进行动态绑定，将派生类对象指针绑定到基类指针上，对象销毁时，如果析构函数没有定义为析构函数，则会调用基类的析构函数，显然只能销毁部分数据。如果要调用对象的析构函数，就需要将该对象的析构函数定义为虚函数，销毁时通过虚函数表找到对应的析构函数。

1
2
//纯虚函数定义
virtual ~myClass() = 0;
析构函数能抛出异常吗
答案肯定是不能。

C++标准指明析构函数不能、也不应该抛出异常。C++异常处理模型最大的特点和优势就是对 C++中的面向对象提供了最强大的无缝支持。那么如果对象在运行期间出现了异常，C++异常处理模型有责任清除那些由于出现异常所导致的已经失效了的对象 (也即对象超出了它原来的作用域)，并释放对象原来所分配的资源， 这就是调用这些对象的析构函数来完成释放资源的任务，所以从这个意义上说，析构函数已经变成了异常处理的一部分。

(1) 如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。

(2) 通常异常发生时，c++的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题。

构造函数和析构函数中调用虚函数吗？


# 内存对齐

作者：oscarwin
链接：https://www.nowcoder.com/discuss/59394
来源：牛客网

从 0 位置开始存储；
变量存储的起始位置是该变量大小的整数倍；
结构体总的大小是其最大元素的整数倍，不足的后面要补齐；
结构体中包含结构体，从结构体中最大元素的整数倍开始存；
如果加入 pragma pack(n) ，取 n 和变量自身大小较小的一个。

# 内联函数

宏定义在预编译的时候就会进行宏替换；

内联函数在编译阶段，在调用内联函数的地方进行替换，减少了函数的调用过程，但是使得编译文件变大。因此，内联函数适合简单函数，对于复杂函数，即使定义了内联编译器可能也不会按照内联的方式进行编译。

内联函数相比宏定义更安全，内联函数可以检查参数，而宏定义只是简单的文本替换。因此推荐使用内联函数，而不是宏定义。

使用宏定义函数要特别注意给所有单元都加上括号，#define MUL(a, b) a b，这很危险，正确写法：#define MUL(a, b) ((a) (b))

# 内存管理

C++ 内存分为那几块？（堆区，栈区，常量区，静态和全局区）
每块存储哪些变量？
学会迁移，可以说到 malloc，从 malloc 说到操作系统的内存管理，说道内核态和用户态，然后就什么高端内存，slab 层，伙伴算法，VMA 可以巴拉巴拉了，接着可以迁移到 fork()。

# STL 的内存池实现

STL 内存分配分为一级分配器和二级分配器，一级分配器就是采用 malloc 分配内存，二级分配器采用内存池。

二级分配器设计的非常巧妙，分别给 8k，16k,..., 128k 等比较小的内存片都维持一个空闲链表，每个链表的头节点由一个数组来维护。需要分配内存时从合适大小的链表中取一块下来。假设需要分配一块 10K 的内存，那么就找到最小的大于等于 10k 的块，也就是 16K，从 16K 的空闲链表里取出一个用于分配。释放该块内存时，将内存节点归还给链表。如果要分配的内存大于 128K 则直接调用一级分配器。

为了节省维持链表的开销，采用了一个 union 结构体，分配器使用 union 里的 next 指针来指向下一个节点，而用户则使用 union 的空指针来表示该节点的地址。

# STL 里的 set 和 map 实现

set 和 map 都是基于红黑树实现的。

红黑树是一种平衡二叉查找树，AVL 树是完全平衡的，红黑树基本上是平衡的。

与 AVL 相比红黑数插入和删除最多只需要 3 次旋转，而 AVL 树为了维持其完全平衡性，在坏的情况下要旋转的次数太多。

# 必须在构造函数初始化列表里进行初始化的数据成员

1. 常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面；
2. 引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面；
3. 没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化。

# 手写 strcpy()

```c++
char* strcpy(char* dest, const char* src)
{
    char *save = dest;
    while (*dest++ = *src++){}
    return save;
}
```

```c++
char src[] = "abc";
char dest[10]; // dest 必须大于 src
strcpy(dest, src);
cout << dest << endl;
```

# 手写 strcat()

```
char* strcat(char* dest, const char* src)
{
    char* save = dest;
    while (*dest) dest++;
    while(*dest++ = *src++){}
    return save;
}
```

# 手写 strcmp()

```c++
int strcmp(const char* s1, const char* s2)
{
    while(*s1 == *s2 && *s1)
    {
        s1++;
        s2++;
    }
    return *s1 - *s2;
}
```

# 手写 strstr()

要求不能用其它库函数。

直接使用暴力方法，每次比较 src 的一部分是否与 target 相等。

循环体只需要执行 N - M + 1 次即可，由于不能用 strlen() ，因此无法直接计算出 N 与 M，可以使用一个额外的指针，令它先从 src 头部移动 M - 1 次，这样它还可以再移动的次数就为 N - M + 1 次。

```c++
char* strstr(const char* src, const char* target)
{
    if (!*target) return (char*)src;
    char *p1 = (char*)src, *p2 = (char*)target;
    char* p1_ahead = (char*)src;
    while (*++p2)
        p1_ahead++;
    while (*p1_ahead++)
    {
        char* p1_begin = p1;
        p2 = (char*)target;
        while (*p1 && *p2 && *p1++ == *p2++)
        {
        }
        if (!*p2) return p1_begin;
        p1 = p1_begin + 1;
    }
    return nullptr;
}
```


# 手写 memcpy()

```c++
void* memcpy(void* dest, const void* src, size_t len)
{
    char* d = (char *)dest;
    const char* s = (char *)src;
    while (len--)
        *d++ = *s++;
    return dest;
}
```

# 最佳实践



# 参考资料

- [C++后台开发面试常见问题汇总 ](https://www.nowcoder.com/discuss/59394)
- [函数 strcpy、strcat 和 strcmp 实现源码 ](http://blog.csdn.net/wangningyu/article/details/4662891)
- [Github : gcc/libgcc/memcpy.c](https://github.com/gcc-mirror/gcc/blob/master/libgcc/memcpy.c)
- [Leetcode : Implement strstr() to Find a Substring in a String](https://articles.leetcode.com/implement-strstr-to-find-substring-in/)