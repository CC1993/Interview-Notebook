# 单元测试简介

单元是指程序划分的最小测试块，可以是函数、类、窗体等。单元测试是程序员在编码阶段进行的，而不像集成测试等是测试人员在程序提交时才进行测试。最简单的单元测试就是对一个函数编写一个测试用例，通过比较测试用例的结果与预期值是否一致来判断程序是否正确。

我们都有过写一大堆控制台输出的代码来验证程序的经历，说明在编程时需要有一种能让我们检验程序的方法，而单元测试就是这种方法。书写控制台输出代码来检验程序也算是一种单元测试，但是不够规范，而且难于满足多种测试要求。比如，控制台输出的代码需要源程序运行才能运行，有时候源程序运行一次的时间就很长。而且如果只想对一部分功能进行测试，那么这就显得特别低效。再比如，控制台的代码会一直留在源代码中，注释又很麻烦。所以，需要有一种比较规范的单元测试方法，接下来介绍的 JUnit 就是 Java 用来单元测试的一个测试框架。

# IDEA 中使用 Junit

有如下计算器类

```java
public class Calculate {
    public int add(int x, int y) {
        return x + y;
    }

    public int divide(int x, int y) {
        return x / y;
    }
}
```

输入指针移到类名上，然后使用 alt + enter 快捷键中的 Create Test 功能，新建单元测试类，选中要测试的方法。还可以选中前置方法 setUp 和后置方法 tearDown。

![](index_files/535b3455-4193-4af2-ad17-ea6e6d08ebfe.png)

补全测试方法。

```java
public class CalculateTest {
    @org.junit.Test
    public void add() {
        Assert.assertEquals(2, new Calculate().add(1, 1));
    }

    @org.junit.Test
    public void divide() {
        Assert.assertEquals(2, new Calculate().divide(4, 2));
    }
}
```

运行该单元测试类，可以看到测试用例的执行情况

![](index_files/e698446c-00c2-444c-a72b-84208c17e2c8.png)

# Junit 使用详解

- 单元测试代码放在单独的目录下，目录下的包结构和源代码保持一致。

- Failure 表示结果和预期不一致；Error 是表示程序出现异常。

- setUp 方法用 @Before 注解修饰，tearDown 用 @After 注解修饰。

- @Test 注解会将一个方法设置为测试方法，该注解有两个属性，expected 和 timeout。expected 用来处理程序出现的异常，如果指定的异常出现，测试代码会通过而不会报错。而 timeout 就是最长的运行时间，如果超出则测试不会通过。

```java
 @org.junit.Test(expected = ArithmeticException.class)
 public void divide() {
     Assert.assertEquals(0, new Calculate().divide(4, 0));
 }
```

- @Ignore 注解让一个测试方法会被忽略。

- 测试套件可以指定要运行的测试类

```java
@RunWith(Suite.class)
@Suite.SuiteClasses({ SuiteTest1.class, SuiteTest2.class })
public class SuiteTest  {}
```

- Parameterized，运行多个测试用例。

```java
@RunWith(Parameterized.class)
public class CalculateTest {
    private int x;    // 实例变量
    private int y;
    private int sum;

    @Parameterized.Parameters
    public static Collection<Object[]> data() {   // 参数化数据
        return Arrays.asList(new Object[][]{
                {0, 0, 0}, {1, 1, 2}, {10, 10, 20}
        });
    }

    public CalculateTest(int x, int y, int sum) {   // 构造函数
        this.x = x;
        this.y = y;
        this.sum = sum;
    }

    @org.junit.Test
    public void add() {
        Assert.assertEquals(sum, new Calculate().add(x, y));
    }
}
```

- @Before：初始化方法，对于每一个测试方法都要执行一次

- @BeforeClass：针对所有测试，只执行一次，且必须为 static void

- @After：释放资源，对于每一个测试方法都要执行一次

- @AfterClass：针对所有测试，只执行一次，且必须为 static void

```java
public class JUnit4Test {
    @Before
    public void before() {
        System.out.println("@Before");
    }

    @After
    public void after() {
        System.out.println("@After");
    }

    @BeforeClass
    public static void beforeClass() {
        System.out.println("@BeforeClass");
    };

    @AfterClass
    public static void afterClass() {
        System.out.println("@AfterClass");
    };
};
```

```html
输出结果：
@BeforeClass
@Before
@After
@AfterClass
```

使用反射测试 private 方法

```java
Method method = targetClass.getDeclaredMethod(methodName, argClasses);
method.setAccessible(true);
return method.invoke(targetObject, argObjects);
```

# 参考资料

- [JUnit—Java 单元测试必备工具 ](http://www.imooc.com/learn/356)
- [How do I test a private function or a class that has private methods, fields or inner classes?](https://stackoverflow.com/questions/34571/how-do-i-test-a-private-function-or-a-class-that-has-private-methods-fields-or)




