# 个人博客：扫二维码登录微信网页版原理分析

http://dreamlikes.cn/archives/325

出于项目要求，需要制作一个扫描二维码登录网页后台的功能。所以研究了下微信网页版的扫二维码登录功能，希望能有所借鉴和收获。

首先我们先来熟悉一下整个扫二维码登录的流程：

1. 打开微信网页版
2. 打开微信客户端 APP
3. 扫网页上的二维码（扫一扫）授权登录
4. 登录成功并跳转

## 原理分析

打开微信网页版的登录页面，按 F12 打开 Chrome 调试模式。

![](index_files/wechat-qrcode-login-1-1024x667.jpg)

我们可以看到，网页先后加载了网页、图片、CSS、Javascript 等资源文件，包括二维码图片。

然后仔细观察会发现，网页会一直在异步请求一个链接，这个链接其实就是在监听服务器，如果有人用微信客户端授权成功，则会返回成功的信息然后跳转；否则继续监听。

这个过程就是整个网页最重要的部分了，通过不断请求来监听状态。所以需要重点分析此请求。

从图中我们还可以看到，右侧，每个请求都是用了 27s 左右。为什么要这么长时间呢？

由于监听和登录操作肯定是短时间内必须完成的，比如我扫完二维码确认登录了，这个页面就要在短时间内做出响应。如果要做到这样，最简单的方法就是通过 Javascript 定时器，每隔几秒请求服务器并获取状态（事实上我同时也研究过新浪微博的扫二维码登录，它就是这样做的，每隔 3-4 秒左右请求一次）。然而这样会直接导致的问题就是，服务器会产生非常高的并发，小用户级别的服务器还没什么，但是像微信这种需要服务庞大用户群的服务器，就必须做这方面的优化。

所以微信的采用的做法就是减少请求并增加响应时间，实现的原理大概就是在服务器端接收到请求后，内部加个定时器不断检查用户授权的状态，如果检测到用户授权则马上响应给网页端；否则继续检查；当时间累积到 27 秒左右，不论成不成功都终止检测并立即响应给网页端。

好了，我们接下来继续观察这个请求的参数：

![](index_files/wechat-qrcode-login-2-1024x668.png)

可以看到总共有五个参数：

- loginicon ：布尔值
- uuid：字符串
- tip ：正整数
- r：负整数
- \_：正整数

从字面上来理解的话，第一个参数大概意思是，是否要有登录图标（true=> 要，false=> 不要）；第二个参数，是指二维码的值，随便测试下就知道了；第三个参数，应该是指是否要提示（1=> 要，0=> 不要）；第四个参数，应该是一个随机数（random）；第五个参数，不难看出这是个 [Unix 时间戳](http://tool.chinaz.com/Tools/unixtime.aspx)。随机数和时间戳跟安全机制有关吧，防止相关的攻击，如重放攻击。

这几个参数当中，最重要的是当然是 uuid 了，因为这是用来向服务器请求授权状态的凭借。并且这个 uuid 必须是唯一不重复的，不然试想下，两个人在不同的电脑下浏览到了同一个二维码，有人授权登录了，可能会是在另一个人电脑上登录微信的网页版。所以说这个唯一的 uuid 是专门用来绑定一个微信账号的授权的。

因为 uuid 一般是随机生成的，但是像这里的这串字符，观察最后两个字符 “==”，又像是经过某个加密算法产生的，不过这并不太重要，确保到 uuid 的唯一不重复性就行了。至于 r 这个参数，我个人猜测这是个随机数。最后一个参数是用来做超时验证操作的，确保一个 uuid 只在短时间内有效，如果你仔细观察，会发现二维码登录页在几分钟内不登录，那么它会自动刷新然后更新过另外一个二维码。最后利用这三个进行某种算法之后生成签名（下面提到的 ticket 值）返回给客户端。

接下来我们看看这个请求的返回值：

![](index_files/wechat-qrcode-login-3.png)

从图中我们可以看到返回的是一条 Javascript 语句，有个状态码 408，这个就是表示用户还没有用微信客户端 APP 授权，需要继续请求监听状态。如果是授权成功，则返回 200，然后登录页会跳转到后台：

```
window.code=200;
window.redirect_uri="https://wx2.qq.com/cgi-bin/mmwebwx-bin/webwxnewloginpage?ticket=A1aIfKKbwSFQF62r2rlGJoMP@qrticket_0&uuid=gfYCj6pglQ==&lang=zh_CN&scan=1456813161";
```

ticket 值就是服务器生成的用户签名，理解为 access_token 即可。

再来看看微信客户端 APP 扫描二维码后的页面：

![](index_files/wechat-qrcode-login-4-577x1024.jpg)

![](index_files/wechat-qrcode-login-5.jpg)

当扫描成功二维码后，会弹出授权窗口，询问是否授权登录。

换个二维码扫描软件可以得到登录时候的二维码字符串实际值如图。经过多次试验可以知道前半段不变的，只有后面的参数会变（即 uuid 值）。

所以分析得到微信客户端的步骤是这样的：

1.  扫描二维码（扫一扫）
2.  如果字符串前半段是 https://login.weixin.qq.com/l/，则弹出授权窗口
3.  如果点击确定，再向服务器请求改变这个 uuid 的状态

完整的流程图：

![](index_files/wechat-qrcode-login-6.png)

至此，整个的扫二维码登录流程就完成了。

# 知乎：微信扫描二维码登录网页是什么原理，前后两个事件是如何联系的？

https://www.zhihu.com/question/20368066/answer/23779470

反对[@朱立雄](//www.zhihu.com/people/7b7e9cb2ebaa0aad29d72c00ee46e41b)的答案，从回答可以看得出来他对技术细节并不了解。对前端开发有了解的同学随便开个 Firebug 看看登录过程的 Net 视图基本就能大概看清楚这个过程。

我个人开发过程一般是和产品说，『你们提业务要求、交互方式、性能要求等就好，技术方案我们会综合开发时间、系统架构等因素考虑』。

恰好我之前也花过几个小时做过类似的验证登录过程，这里作为探讨，把产品同学的回答做个引用，解释一下其中『不技术』的地方。

> 每打开一次[微信网页版](https://link.zhihu.com/?target=http%3A//wx.qq.com/)页面的时候会随机生成一个含有唯一 uid 的二维码，每次刷新页面都会不一样（这个可以保证一个 uid 只可以绑定一个账号和密码，如果一个 uid 可以绑定多个账号和密码，那么很可能你的电脑会登陆别人的微信哦）；

确实返回了唯一 id，但目的是为了识别用户身份，而且实际上打开这个页面的时候浏览器已经和 Server 创建了一个长连接等待确认信息。

查看 [http://wx.qq.com](https://link.zhihu.com/?target=http%3A//wx.qq.com) 的源码可以看到，这个页面在加载完毕时，也已经把很多登录后才需要的相关资源都预先加载进来了，所以长连接等待登录用户得到确认后展示用户信息的速度很快，因为无需刷页面和加载头像外的其他资源。

> 当用户使用登陆后的微信扫描该二维码的时候，会将这个 id 和手机上的微信账号及密码绑定，并上传到[微信网页版](https://link.zhihu.com/?target=http%3A//login.weixin.qq.com/)服务器；

先上个图：

![](index_files/a6e714b115b03b60b294f87090e488ce_hd.jpg)

二维码样例： https://link.zhihu.com/?target=http%3A//weixin.qq.com/x/ARmFYVvUzczwBl9u6Y1I ，利用我查查之类的二维码应用可以得到类似这样的地址，但并不会自动打开该地址，微信客户端针对 http://weixin.qq.com/x/ 开头的地址做了特殊处理，会自动获取相关信息并提示确认。在手机版微信访问这个页面进行确认时，Server 已经同时获得了客户端信息，并通过之前保持的长连接告知浏览器。

> [微信网页版](https://link.zhihu.com/?target=http%3A//wx.qq.com/)页面每隔 1 秒或 2 秒会 get 请求该 id 对应的微信账号及密码，如果 id 绑定上了微信账号和密码，那么就可以请求到账号和密码，就可以自动登陆了。

浏览器展示完长连接里包含的用户信息（头像等）后，会新开一个长连接等待客户端的确认操作，其 URL 类似 https://login.weixin.qq.com/cgi-bin/mmwebwx-bin/login?uuid=794ecedd804f47&tip=1&_=1395748413642。从安全的角度来说，无论如何都不会让客户端获得微信帐号和密码的。要知道，密码这玩意腾讯自己都不敢保存（有兴趣的同学可以自行了解下 CSDN 明文密码泄露事件），肯定是不可能返回给浏览器的。

而且从体感来看，怎么着都不可能是页面 1-2 秒轮询发起 GET 请求的，实际是通过堵塞等待的长连接，近乎实时的获得信息。 对于验证过程，Open API 一般是通过授权令牌（Token）来解决的，原理是当用户通过授权后，分配一个限定条件下的令牌（如限制本机访问、限制授权有效时间、限制同时登录设备数等），使获得授权的用户仅在有限的前提下能访问相关服务。 像计算机休眠后曾做的授权就自动收回了，这样就有效的避免了在别人电脑上（尤其是网吧）打开，但忘记关闭或退出这类安全问题了。

同时，整个授权过程的验证部分在手机端进行，有效杜绝了 PC 上泛滥的各类木马、『安全工具』的监听，大大降低了帐号被盗的风险。

所以说，核心过程应该是：浏览器获得一个临时 id，通过长连接等待客户端扫描带有此 id 的二维码后，从长连接中获得客户端上报给 server 的帐号信息进行展示。 并在客户端点击确认后，获得服务器授信的令牌，进行随后的信息交互过程。 在超时、网络断开、其他设备上登录后，此前获得的令牌或丢失、或失效，对授权过程形成有效的安全防护。
